## Queue

큐(Queue)는 데이터를 관리하는 방식 중 하나로, First In First Out(FIFO) 원칙을 따릅니다. 이 원칙은 '먼저 들어온 데이터가 먼저 나간다'는 것을 의미합니다. 다시 말하면, 가장 먼저 큐에 추가된 항목이 가장 먼저 제거되는 구조를 가지고 있습니다.

![큐](https://github.com/velyvelylovely/DataStructure/assets/98696925/d71c9bb8-b675-44fe-bf5f-10e81deeee44)

### 큐 주요 동작

- enqueue: 큐에 항목을 추가하는 작업을 말합니다. 새로운 항목들은 항상 큐의 마지막 부분에 추가됩니다.
- dequeue: 큐에서 항목을 제거하는 작업을 말합니다. FIFO 원칙에 따라 항상 가장 먼저 들어온 항목이 제거됩니다.
- peek: 큐의 첫 번째 항목을 확인하는 작업입니다. 이 때 주목할 점은 peek 동작은 단순히 첫 번째 항목을 확인만 하며 실제로 그 항목을 큐에서 제거하지 않습니다.

### 큐 사용 사례: Producer/consumer architecture

프로듀서와 컨슈머라는 두 주체가 협력하여 작업을 효과적으로 수행하는데 큐(Queue)는 중요한 역할을 합니다. 이 아키텍처는 다양한 분야에서 사용되며, 특히 병렬 처리가 필요한 백엔드 시스템에서 널리 사용됩니다.

프로듀서는 데이터나 작업 항목을 생성하고, 이를 큐에 넣습니다(enqueue). 큐는 일종의 버퍼 혹은 중간 저장소 역할을 하며, 프로듀서가 만든 항목들이 여기에 순차적으로 쌓이게 됩니다. 이러한 구성은 작업의 분산과 처리를 효율적으로 관리하는데 큰 도움이 됩니다.

컨슈머는 큐에 들어있는 항목들을 순차적으로 꺼내고(dequeue) 처리합니다. 

더 나아가 여러 개의 컨슈머가 하나의 큐에 동시에 접근하는 경우, 각 컨슈머는 큐에서 작업을 꺼내와서 처리할 수 있습니다. 이로 인해 병렬 처리가 가능하며, 작업이 더 빨리 완료될 수 있습니다.

이러한 병렬 처리를 구현하려면 적절한 동기화 및 동시성 관리가 필요하며, 다수의 컨슈머가 동시에 작업을 선택하도록 설계된 큐를 사용해야 합니다. 그렇게 하면 다수의 컨슈머가 동시에 작업을 처리할 수 있습니다.

### 기술 문서에서 큐를 만났을 때 팁

>[!NOTE]
>항상 FIFO를 의미하지는 않음

큐(Queue)는 데이터를 First In First Out (FIFO) 순서로 처리하는 데이터 구조로 널리 알려져 있습니다. 하지만 기술 문서를 읽다 보면 모든 큐가 엄밀히 FIFO를 따르지는 않을 수 있습니다. 

멀티태스킹을 예로 들어 설명하겠습니다. 가령, CPU가 다루어야 할 프로세스가 P1, P2, P3 세 개가 있다고 가정해봅시다. 싱글 코어 환경에서는 CPU가 동시에 세 개의 프로세스를 실행할 수 없으며, 한 번에 하나의 프로세스만 실행됩니다.

멀티태스킹은 이렇게 번갈아가면서 실행되는데, P1이 실행되는 동안 P2와 P3는 레디큐(대기 큐)에 대기합니다. 큐라는 용어만 보면 FIFO 원칙이 적용되는 것처럼 생각할 수 있지만, 항상 그런 것은 아닙니다.

실제로는 프라이어티 큐(우선순위 큐)와 같은 변형된 큐도 있습니다. 이러한 큐에서는 우선순위가 높은 항목이 먼저 처리됩니다. 큐의 용어는 데이터를 저장하고 처리하는 방법을 나타내는 것으로, 반드시 FIFO를 따라야 하는 것은 아닙니다.

따라서 큐를 다룰 때에는 문서나 문맥에서 어떤 종류의 큐를 다루는지를 주의깊게 살펴보고, 큐의 동작 방식을 정확하게 이해하는 것이 중요합니다.
